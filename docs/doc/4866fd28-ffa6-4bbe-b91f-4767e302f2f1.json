{
    "summary": "The code has functions to add grids to images and capture screenshots using PIL, accepting input in various formats. It saves the captured image at a specified file path or displays an error message for unsupported platforms.",
    "details": [
        {
            "comment": "The code imports necessary libraries and defines a function to add a grid to an image. It loads the original image, creates a drawing object, gets the image size, and reduces the font size for the grid.",
            "location": "\"/media/root/Toshiba XG3/works/self-operating-computer/docs/src/operate/utils/screenshot.py\":0-38",
            "content": "import os\nimport platform\nimport subprocess\nimport pyautogui\nfrom PIL import Image, ImageDraw, ImageGrab\nimport Xlib.display\nimport Xlib.X\nimport Xlib.Xutil  # not sure if Xutil is necessary\nfrom operate.settings import Config\nfrom operate.prompts import ACCURATE_PIXEL_COUNT\n# Load configuration\nconfig = Config()\nmonitor_size = config.monitor_size\ndef add_grid_to_image(original_image_path, new_image_path, grid_interval):\n    \"\"\"\n    Add a grid to an image.\n    Args:\n        original_image_path (str): The file path of the original image.\n        new_image_path (str): The file path to save the new image with the grid.\n        grid_interval (int): The interval between grid lines in pixels.\n    Returns:\n        None: The function saves the new image with the grid at the specified path.\n    \"\"\"\n    # Load the image\n    image = Image.open(original_image_path)\n    # Create a drawing object\n    draw = ImageDraw.Draw(image)\n    # Get the image size\n    width, height = image.size\n    # Reduce the font size a bit\n    font_size = int(grid_interval / 10)  # Reduced font size"
        },
        {
            "comment": "This function creates a background rectangle for text and draws it with white fill. It also draws vertical lines and labels at every `grid_interval` pixels.",
            "location": "\"/media/root/Toshiba XG3/works/self-operating-computer/docs/src/operate/utils/screenshot.py\":40-62",
            "content": "    # Calculate the background size based on the font size\n    bg_width = int(font_size * 4.2)  # Adjust as necessary\n    bg_height = int(font_size * 1.2)  # Adjust as necessary\n    # Function to draw text with a white rectangle background\n    def draw_label_with_background(\n        position, text, draw, font_size, bg_width, bg_height\n    ):\n        # Adjust the position based on the background size\n        text_position = (position[0] + bg_width // 2, position[1] + bg_height // 2)\n        # Draw the text background\n        draw.rectangle(\n            [position[0], position[1], position[0] + bg_width, position[1] + bg_height],\n            fill=\"white\",\n        )\n        # Draw the text\n        draw.text(text_position, text, fill=\"black\", font_size=font_size, anchor=\"mm\")\n    # Draw vertical lines and labels at every `grid_interval` pixels\n    for x in range(grid_interval, width, grid_interval):\n        line = ((x, 0), (x, height))\n        draw.line(line, fill=\"blue\")\n        for y in range(grid_interval, height, grid_interval):"
        },
        {
            "comment": "Calculates the percentage of coordinates and draws labels with background. Draws horizontal lines for grid labels. Saves the image with the grid at specified file path.",
            "location": "\"/media/root/Toshiba XG3/works/self-operating-computer/docs/src/operate/utils/screenshot.py\":63-91",
            "content": "            # Calculate the percentage of the width and height\n            x_percent = round((x / width) * 100)\n            y_percent = round((y / height) * 100)\n            draw_label_with_background(\n                (x - bg_width // 2, y - bg_height // 2),\n                f\"{x_percent}%,{y_percent}%\",\n                draw,\n                font_size,\n                bg_width,\n                bg_height,\n            )\n    # Draw horizontal lines - labels are already added with vertical lines\n    for y in range(grid_interval, height, grid_interval):\n        line = ((0, y), (width, y))\n        draw.line(line, fill=\"blue\")\n    # Save the image with the grid\n    image.save(new_image_path)\ndef capture_mini_screenshot_with_cursor(\n    file_path=os.path.join(\"screenshots\", \"screenshot_mini.png\"), x=0, y=0\n):\n    \"\"\"\n    Capture a mini screenshot with the cursor at the specified coordinates.\n    Args:\n        file_path (str, optional): The file path to save the screenshot. Defaults to \"screenshots/screenshot_mini.png\"."
        },
        {
            "comment": "This code is used to take a screenshot of a specific area on the user's monitor using the Python Imaging Library (PIL) and ImageGrab modules. It takes optional x and y coordinates as inputs, which can be specified as integers or percentage strings. The function converts the input values into the appropriate format for calculating the coordinates of the rectangle to capture the screenshot. If the user is on a Linux system, it performs additional calculations to convert percentage-based input into actual pixel coordinates and upscales the image for better visibility.",
            "location": "\"/media/root/Toshiba XG3/works/self-operating-computer/docs/src/operate/utils/screenshot.py\":92-113",
            "content": "        x (int or str, optional): The x-coordinate of the cursor position. Can be specified as an integer or a percentage string. Defaults to 0.\n        y (int or str, optional): The y-coordinate of the cursor position. Can be specified as an integer or a percentage string. Defaults to 0.\n    \"\"\"\n    user_platform = platform.system()\n    if user_platform == \"Linux\":\n        x = float(x[:-1])  # convert x from \"50%\" to 50.\n        y = float(y[:-1])\n        x = (x / 100) * monitor_size[\n            \"width\"\n        ]  # convert x from 50 to 0.5 * monitor_width\n        y = (y / 100) * monitor_size[\"height\"]\n        # Define the coordinates for the rectangle\n        x1, y1 = int(x - ACCURATE_PIXEL_COUNT / 2), int(y - ACCURATE_PIXEL_COUNT / 2)\n        x2, y2 = int(x + ACCURATE_PIXEL_COUNT / 2), int(y + ACCURATE_PIXEL_COUNT / 2)\n        screenshot = ImageGrab.grab(bbox=(x1, y1, x2, y2))\n        screenshot = screenshot.resize(\n            (screenshot.width * 2, screenshot.height * 2), Image.LANCZOS\n        )  # upscale the image so it's easier to see and percentage marks more visible"
        },
        {
            "comment": "Code is capturing a screenshot based on user platform. For non-Darwin platforms, it saves the screenshot, while for Darwin (macOS), it uses screencapture utility to capture the screen with cursor and saves the result. Both versions save the grid screenshot as well.",
            "location": "\"/media/root/Toshiba XG3/works/self-operating-computer/docs/src/operate/utils/screenshot.py\":114-142",
            "content": "        screenshot.save(file_path)\n        screenshots_dir = \"screenshots\"\n        grid_screenshot_filename = os.path.join(\n            screenshots_dir, \"screenshot_mini_with_grid.png\"\n        )\n        add_grid_to_image(\n            file_path, grid_screenshot_filename, int(ACCURATE_PIXEL_COUNT / 2)\n        )\n    elif user_platform == \"Darwin\":\n        x = float(x[:-1])  # convert x from \"50%\" to 50.\n        y = float(y[:-1])\n        x = (x / 100) * monitor_size[\n            \"width\"\n        ]  # convert x from 50 to 0.5 * monitor_width\n        y = (y / 100) * monitor_size[\"height\"]\n        x1, y1 = int(x - ACCURATE_PIXEL_COUNT / 2), int(y - ACCURATE_PIXEL_COUNT / 2)\n        width = ACCURATE_PIXEL_COUNT\n        height = ACCURATE_PIXEL_COUNT\n        # Use the screencapture utility to capture the screen with the cursor\n        rect = f\"-R{x1},{y1},{width},{height}\"\n        subprocess.run([\"screencapture\", \"-C\", rect, file_path])\n        screenshots_dir = \"screenshots\"\n        grid_screenshot_filename = os.path.join("
        },
        {
            "comment": "This code captures a screenshot of the computer's display with cursor and saves it to the specified file path. It checks the user platform (Windows, Linux, or Mac OS) and uses appropriate libraries to capture the screenshot.",
            "location": "\"/media/root/Toshiba XG3/works/self-operating-computer/docs/src/operate/utils/screenshot.py\":143-177",
            "content": "            screenshots_dir, \"screenshot_mini_with_grid.png\"\n        )\n        add_grid_to_image(\n            file_path, grid_screenshot_filename, int(ACCURATE_PIXEL_COUNT / 2)\n        )\ndef capture_screen_with_cursor(file_path):\n    \"\"\"\n    Capture the screen with the cursor and save it to the specified file path.\n    Args:\n        file_path (str): The file path where the screenshot will be saved.\n    Raises:\n        None\n    Returns:\n        None\n    \"\"\"\n    user_platform = platform.system()\n    if user_platform == \"Windows\":\n        screenshot = pyautogui.screenshot()\n        screenshot.save(file_path)\n    elif user_platform == \"Linux\":\n        # Use xlib to prevent scrot dependency for Linux\n        screen = Xlib.display.Display().screen()\n        size = screen.width_in_pixels, screen.height_in_pixels\n        monitor_size[\"width\"] = size[0]\n        monitor_size[\"height\"] = size[1]\n        screenshot = ImageGrab.grab(bbox=(0, 0, size[0], size[1]))\n        screenshot.save(file_path)\n    elif user_platform == \"Darwin\":  # (Mac OS)"
        },
        {
            "comment": "This code captures a screenshot of the computer screen with the cursor, or prints an error message if the platform is not supported.",
            "location": "\"/media/root/Toshiba XG3/works/self-operating-computer/docs/src/operate/utils/screenshot.py\":178-181",
            "content": "        # Use the screencapture utility to capture the screen with the cursor\n        subprocess.run([\"screencapture\", \"-C\", file_path])\n    else:\n        print(f\"The platform you're using ({user_platform}) is not currently supported\")"
        }
    ]
}