{
    "summary": "The code includes functions for handling image data, such as drawing bounding boxes and validating overlaps, as well as encoding tasks like converting images to base64 and formatting message content by removing triple backticks and calculating click positions.",
    "details": [
        {
            "comment": "The code defines two functions:\n1. `validate_and_extract_image_data`: Validates the given data and extracts image URL if the request is valid.\n2. `get_label_coordinates`: Retrieves the coordinates for a given label from a dictionary of labels and their coordinates.",
            "location": "\"/media/root/Toshiba XG3/works/self-operating-computer/docs/src/operate/utils/label.py\":0-36",
            "content": "import io\nimport base64\nimport json\nimport os\nimport time\nimport asyncio\nfrom PIL import Image, ImageDraw\ndef validate_and_extract_image_data(data):\n    if not data or \"messages\" not in data:\n        raise ValueError(\"Invalid request, no messages found\")\n    messages = data[\"messages\"]\n    if (\n        not messages\n        or not isinstance(messages, list)\n        or not messages[-1].get(\"image_url\")\n    ):\n        raise ValueError(\"No image provided or incorrect format\")\n    image_data = messages[-1][\"image_url\"][\"url\"]\n    if not image_data.startswith(\"data:image\"):\n        raise ValueError(\"Invalid image format\")\n    return image_data.split(\"base64,\")[-1], messages\ndef get_label_coordinates(label, label_coordinates):\n    \"\"\"\n    Retrieves the coordinates for a given label.\n    :param label: The label to find coordinates for (e.g., \"~1\").\n    :param label_coordinates: Dictionary containing labels and their coordinates.\n    :return: Coordinates of the label or None if the label is not found.\n    \"\"\"\n    return label_coordinates.get(label)"
        },
        {
            "comment": "The function `is_overlapping` checks if two boxes overlap by comparing their coordinates. If there is no overlap, the function returns False; otherwise, it returns True.\n\nThe `add_labels` function decodes base64 data into image bytes and opens it as an image using PIL. It creates copies of the original image and a debug image. The YOLO model applies object detection on the image. The code then draws on the images using the ImageDraw module, and stores label coordinates in a dictionary named `label_coordinates`.",
            "location": "\"/media/root/Toshiba XG3/works/self-operating-computer/docs/src/operate/utils/label.py\":39-71",
            "content": "def is_overlapping(box1, box2):\n    x1_box1, y1_box1, x2_box1, y2_box1 = box1\n    x1_box2, y1_box2, x2_box2, y2_box2 = box2\n    # Check if there is no overlap\n    if x1_box1 > x2_box2 or x1_box2 > x2_box1:\n        return False\n    if (\n        y1_box1 > y2_box2 or y1_box2 > y2_box1\n    ):  # Adjusted to check 100px proximity above\n        return False\n    return True\ndef add_labels(base64_data, yolo_model):\n    image_bytes = base64.b64decode(base64_data)\n    image_labeled = Image.open(io.BytesIO(image_bytes))  # Corrected this line\n    image_debug = image_labeled.copy()  # Create a copy for the debug image\n    image_original = (\n        image_labeled.copy()\n    )  # Copy of the original image for base64 return\n    results = yolo_model(image_labeled)\n    draw = ImageDraw.Draw(image_labeled)\n    debug_draw = ImageDraw.Draw(\n        image_debug\n    )  # Create a separate draw object for the debug image\n    font_size = 45\n    detections_dir = \"detections\"\n    label_coordinates = {}  # Dictionary to store coordinates"
        },
        {
            "comment": "Creates a directory for detections if it doesn't exist. Loops through the results, drawing bounding boxes and labels on images. Avoids redrawing over existing boxes by checking overlaps before redrawing as red boxes.",
            "location": "\"/media/root/Toshiba XG3/works/self-operating-computer/docs/src/operate/utils/label.py\":73-100",
            "content": "    if not os.path.exists(detections_dir):\n        os.makedirs(detections_dir)\n    counter = 0\n    drawn_boxes = []  # List to keep track of boxes already drawn\n    for result in results:\n        if hasattr(result, \"boxes\"):\n            for det in result.boxes:\n                bbox = det.xyxy[0]\n                x1, y1, x2, y2 = bbox.tolist()\n                debug_label = \"D_\" + str(counter)\n                debug_index_position = (x1, y1 - font_size)\n                debug_draw.rectangle([(x1, y1), (x2, y2)], outline=\"blue\", width=1)\n                debug_draw.text(\n                    debug_index_position,\n                    debug_label,\n                    fill=\"blue\",\n                    font_size=font_size,\n                )\n                overlap = any(\n                    is_overlapping((x1, y1, x2, y2), box) for box in drawn_boxes\n                )\n                if not overlap:\n                    draw.rectangle([(x1, y1), (x2, y2)], outline=\"red\", width=1)\n                    label = \"~\" + str(counter)"
        },
        {
            "comment": "Code saves labeled, debug, and original images with timestamped file names. It also writes the labeled image to a BytesIO object for potential future use.",
            "location": "\"/media/root/Toshiba XG3/works/self-operating-computer/docs/src/operate/utils/label.py\":101-127",
            "content": "                    index_position = (x1, y1 - font_size)\n                    draw.text(\n                        index_position,\n                        label,\n                        fill=\"red\",\n                        font_size=font_size,\n                    )\n                    # Add the non-overlapping box to the drawn_boxes list\n                    drawn_boxes.append((x1, y1, x2, y2))\n                    label_coordinates[label] = (x1, y1, x2, y2)\n                    counter += 1\n    # Save the image\n    timestamp = time.strftime(\"%Y%m%d-%H%M%S\")\n    output_path = os.path.join(detections_dir, f\"img_{timestamp}_labeled.png\")\n    output_path_debug = os.path.join(detections_dir, f\"img_{timestamp}_debug.png\")\n    output_path_original = os.path.join(detections_dir, f\"img_{timestamp}_original.png\")\n    image_labeled.save(output_path)\n    image_debug.save(output_path_debug)\n    image_original.save(output_path_original)\n    buffered_original = io.BytesIO()\n    image_original.save(buffered_original, format=\"PNG\")  # I guess this is needed"
        },
        {
            "comment": "Convert image to base64 for return\nCode is saving the labeled image as PNG and encoding it in base64 format",
            "location": "\"/media/root/Toshiba XG3/works/self-operating-computer/docs/src/operate/utils/label.py\":128-151",
            "content": "    img_base64_original = base64.b64encode(buffered_original.getvalue()).decode(\"utf-8\")\n    # Convert image to base64 for return\n    buffered_labeled = io.BytesIO()\n    image_labeled.save(buffered_labeled, format=\"PNG\")  # I guess this is needed\n    img_base64_labeled = base64.b64encode(buffered_labeled.getvalue()).decode(\"utf-8\")\n    return img_base64_labeled, img_base64_original, label_coordinates\ndef parse_click_content(message_content):\n    \"\"\"\n    Parses the response message to determine if it's a CLICK or NONE action and returns the appropriate data.\n    :param message_content: The content of the response message.\n    :return: A dictionary with the relevant data or a message indicating a NONE action.\n    \"\"\"\n    try:\n        # Check for and remove erroneous ```json at the start and ``` at the end\n        if message_content.startswith(\"```json\"):\n            message_content = message_content[\n                len(\"```json\") :\n            ]  # Remove starting ```json\n            if message_content.endswith(\"```\"):"
        },
        {
            "comment": "This function takes in a message content formatted with triple backticks and removes them. If the format is invalid, it returns an error message. It also has another function that calculates the click position at the center of a bounding box and converts it to percentages.",
            "location": "\"/media/root/Toshiba XG3/works/self-operating-computer/docs/src/operate/utils/label.py\":152-179",
            "content": "                message_content = message_content[: -len(\"```\")]  # Remove ending ```\n        # Convert JSON string to dictionary\n        return json.loads(message_content.strip())\n    except json.JSONDecodeError as e:\n        return {\"error\": \"Invalid JSON format\"}\n    return {\"error\": \"Invalid response format\"}\ndef get_click_position_in_percent(coordinates, image_size):\n    \"\"\"\n    Calculates the click position at the center of the bounding box and converts it to percentages.\n    :param coordinates: A tuple of the bounding box coordinates (x1, y1, x2, y2).\n    :param image_size: A tuple of the image dimensions (width, height).\n    :return: A tuple of the click position in percentages (x_percent, y_percent).\n    \"\"\"\n    if not coordinates or not image_size:\n        return None\n    # Calculate the center of the bounding box\n    x_center = (coordinates[0] + coordinates[2]) / 2\n    y_center = (coordinates[1] + coordinates[3]) / 2\n    # Convert to percentages\n    x_percent = (x_center / image_size[0]) * 100\n    y_percent = (y_center / image_size[1]) * 100"
        },
        {
            "comment": "Computes x and y percentages from input values.",
            "location": "\"/media/root/Toshiba XG3/works/self-operating-computer/docs/src/operate/utils/label.py\":181-181",
            "content": "    return x_percent, y_percent"
        }
    ]
}